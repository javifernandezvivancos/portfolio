using UnityEngine;
using System.Collections;

public class Shooter : MonoBehaviour
{
	//Customizable variables
	public float giroSpeed;										//how fast the shooter can turn
	public Ball BallRed,BallGreen,BallBlue,BallYellow,BallDeath;//each ball which can be generated by the shooter
	public int misileSpeed;										//power
	public float fireRate;										//how many balls can shoot per second
	public int numberOfBullets;
	
	//position where each ball is going to be generated
	private Ball[] bullets;
	private Vector3[] positions;
	private Scene scene;
   	private float nextFire;		//iterator to calculate the next fire
	
	void Start(){
		giroSpeed= 0.8f;
		misileSpeed = 50;
		fireRate = 0.4F;
		numberOfBullets= 5;
		nextFire = 0.0F;
		bullets= new Ball[numberOfBullets];
		positions= new Vector3[numberOfBullets];
		positions[0]= new Vector3(0,(float)0.5,0);
		positions[1]= new Vector3((float)-2.1,(float)0.5,(float)0.4);
		positions[2]= new Vector3((float)-3.4,(float)0.5,(float)-2.3);
		positions[3]= new Vector3((float)-2,(float)0.5,(float)-4);
		positions[4]= new Vector3((float)0.7,(float)0.5,(float)-4.8);
		
		for(int i=0; i<numberOfBullets;i++){
			bullets[i]= createBall(positions[i],false, false);	//Creates a random ball in each slot
		}	
		scene = (Scene)FindObjectOfType(typeof(Scene));
	}
	
	public int getNumberOfBullets(){
		return numberOfBullets;
	}
	
	int generateRandom(){
		//Generates a random from 0 to 4
		float number= Random.value;
		if (number<0.25){
			return 0;
		}
		else if (number<0.50){
			return 1;
		}
		else if(number<0.75){
			return 2;
		}
		else{
			return 3;
		}		
	}
	
	public void hideBalls(){
		for(int i=0;i<numberOfBullets;i++){
			bullets[i].renderer.enabled= false;
		}
	}
	public void showBalls(){
		for(int i=0;i<numberOfBullets;i++){
			bullets[i].renderer.enabled= true;
		}
	}
	
	//move the balls of the slots one position
	void moveSlots(){
		if(!scene.reverse){
			for(int i=0;i<numberOfBullets-1;i++){
				bullets[i]= bullets[i+1];
			}
			bullets[numberOfBullets-1]= createBall(positions[numberOfBullets-1],false,false);
			bullets[0].transform.position= positions[0];
		}
		else{
			for(int i=numberOfBullets-1;i>0;i--){
				bullets[i]= bullets[i-1];
			}
			bullets[0]= createBall(positions[0],false,false);
			bullets[numberOfBullets-1].transform.position= positions[numberOfBullets-1];
		}
		for(int i=1;i<numberOfBullets-1;i++){
			bullets[i].transform.position= positions[i];
		}
	}
	
	//creates a random ball in a position able to detect collisions or not, if the bool variable deathBall is true
	//it will creates a deathBall
	public Ball createBall(Vector3 position, bool collisions, bool deathBall){
		int random= generateRandom();
		Ball colorBall;
		Ball resultBall;
		if(!deathBall){
			if(random==0){
				colorBall= BallRed;		
				colorBall.setColor(0);	
			}
			else if(random==1){
				colorBall= BallGreen;
				colorBall.setColor(1);			
			}
			else if(random==2){
				colorBall= BallYellow;
				colorBall.setColor(2);	
				
			}
			else{
				colorBall= BallBlue;	
				colorBall.setColor(3);	
			}
		}
		else{			
			colorBall= BallDeath;	
			colorBall.setColor(4);	
		}
     	resultBall= Instantiate(colorBall, position, Quaternion.identity) as Ball;
		resultBall.setColor(colorBall.getColor());
		if(collisions){
			resultBall.rigidbody.detectCollisions=true;
			resultBall.rigidbody.isKinematic=false;
		}
		else{
			resultBall.rigidbody.detectCollisions=false;
			resultBall.rigidbody.isKinematic=true;
		}
		return resultBall;
	}
	
	//shootes the shooter
	void shoot(){	
		Ball shootedBall;
		if(!scene.reverse){
			shootedBall= bullets[0];			
		}
		else{
			shootedBall= bullets[numberOfBullets-1];
		}
		shootedBall.unHide();
		scene.addShoot();
		shootedBall.rigidbody.detectCollisions= true;	//changes the attributes of the first ball to crash others
		shootedBall.rigidbody.isKinematic= false;
       	shootedBall.rigidbody.velocity = transform.TransformDirection (Vector3.forward * misileSpeed);	//shoot
		Physics.IgnoreCollision(shootedBall.transform.root.collider, transform.root.collider);			//ignore collsion with the shooter
		scene.setShootedBall(shootedBall);				//Set the shooted ball in the Scene (the only one which can hit a lineBall)
	}
	
	void FixedUpdate () 
	{		
    	// Generate a plane that intersects the transform's position with an upwards normal.
    	Plane playerPlane = new Plane(Vector3.up, transform.position);
 
    	// Generate a ray from the cursor position
    	Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
 
    	// Determine the point where the cursor ray intersects the plane.
    	// This will be the point that the object must look towards to be looking at the mouse.
    	// Raycasting to a Plane object only gives us a distance, so we'll have to take the distance,
    	//   then find the point along that ray that meets that distance.  This will be the point
    	//   to look at.
    	float hitdist = 0.0f;
    	// If the ray is parallel to the plane, Raycast will return false.
    	if (playerPlane.Raycast (ray, out hitdist)) 
		{
        	// Get the point along the ray that hits the calculated distance.
        	Vector3 targetPoint = ray.GetPoint(hitdist);
 
        	// Determine the target rotation.  This is the rotation if the transform looks at the target point.
        	Quaternion targetRotation = Quaternion.LookRotation(targetPoint - transform.position);
 
        	// Smoothly rotate towards the target point.
        	transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, giroSpeed * Time.time);
		}
    	if ((Input.GetButton("Fire1")) && (Time.time>nextFire) && (!scene.isFrozen())) {
    	    nextFire = Time.time + fireRate;
			shoot();
			moveSlots();
    	}    	
    }
}